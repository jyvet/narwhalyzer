/*
 * narwhalyzer.h
 * 
 * Runtime support header for the Narwhalyzer GCC instrumentation plugin.
 * This header is automatically injected into translation units that use
 * the #pragma narwhalyzer directive.
 * 
 * Copyright (c) 2026
 * Licensed under GPL-3.0 License
 */

#ifndef NARWHALYZER_H
#define NARWHALYZER_H

#include <stdint.h>
#include <stddef.h>

#ifdef __cplusplus
extern "C" {
#endif

/* Maximum nesting depth for sections */
#define NARWHALYZER_MAX_NESTING_DEPTH 64

/* Maximum number of distinct sections */
#define NARWHALYZER_MAX_SECTIONS 1024

/* Maximum length of section name */
#define NARWHALYZER_MAX_NAME_LEN 256

/*
 * Section statistics structure.
 * Holds all profiling data for a single instrumented section.
 */
typedef struct narwhalyzer_section_stats {
    const char *name;                   /* Section name from pragma */
    const char *file;                   /* Source file */
    int line;                           /* Line number */
    uint64_t entry_count;               /* Number of times section was entered */
    uint64_t cumulative_time_ns;        /* Total time spent in section (nanoseconds) */
    uint64_t min_time_ns;               /* Minimum single execution time */
    uint64_t max_time_ns;               /* Maximum single execution time */
    int parent_index;                   /* Index of parent section (-1 if root) */
    int depth;                          /* Nesting depth when this section runs */
} narwhalyzer_section_stats_t;

/*
 * Context structure for tracking active section execution.
 * Used to handle nested sections and compute elapsed time.
 */
typedef struct narwhalyzer_context {
    int section_index;                  /* Index into global stats array */
    uint64_t start_time_ns;             /* Entry timestamp */
    int parent_context_index;           /* Index of parent context in stack */
} narwhalyzer_context_t;

/*
 * RAII-style cleanup handle for automatic section exit tracking.
 * Used with __attribute__((cleanup)) for handling all exit paths.
 */
typedef struct narwhalyzer_scope_guard {
    int context_index;                  /* Index into context stack */
    int valid;                          /* Whether this guard is active */
} narwhalyzer_scope_guard_t;

/*
 * Initialize the Narwhalyzer runtime.
 * Called automatically via constructor attribute.
 */
void __narwhalyzer_init(void);

/*
 * Finalize and print the profiling report.
 * Called automatically via destructor attribute or atexit.
 */
void __narwhalyzer_fini(void);

/*
 * Register a new section with the runtime.
 * Returns the section index for subsequent calls.
 * Thread-safe: uses atomic operations for registration.
 * 
 * @param name     Section name from pragma
 * @param file     Source file name
 * @param line     Line number of pragma
 * @return         Section index (>= 0) or -1 on error
 */
int __narwhalyzer_register_section(const char *name, const char *file, int line);

/*
 * Record section entry.
 * Captures timestamp and updates entry counter.
 * 
 * @param section_index  Index returned by register_section
 * @return               Context index for pairing with exit call
 */
int __narwhalyzer_section_enter(int section_index);

/*
 * Record section exit.
 * Computes elapsed time and updates statistics.
 * 
 * @param context_index  Context index returned by section_enter
 */
void __narwhalyzer_section_exit(int context_index);

/*
 * Cleanup function for scope guard.
 * Used with __attribute__((cleanup)) to ensure exit is recorded
 * even on early return, break, goto, etc.
 * 
 * @param guard  Pointer to scope guard structure
 */
void __narwhalyzer_scope_guard_cleanup(narwhalyzer_scope_guard_t *guard);

/*
 * Get current high-resolution monotonic timestamp.
 * Uses CLOCK_MONOTONIC_RAW for best accuracy.
 * 
 * @return  Timestamp in nanoseconds
 */
uint64_t __narwhalyzer_get_timestamp_ns(void);

/*
 * Check if the runtime has been initialized.
 * 
 * @return  Non-zero if initialized, zero otherwise
 */
int __narwhalyzer_is_initialized(void);

/*
 * Macro for automatic section instrumentation.
 * This is the typical pattern inserted by the GCC plugin.
 * 
 * Usage (generated by plugin):
 *   NARWHALYZER_SECTION_BEGIN(section_name, __FILE__, __LINE__)
 *   {
 *       // original code
 *   }
 * 
 * The scope guard ensures exit is recorded on any exit path.
 */
#define NARWHALYZER_SECTION_BEGIN(name, file, line) \
    do { \
        static int __narwhalyzer_section_idx_##line = -1; \
        if (__builtin_expect(__narwhalyzer_section_idx_##line < 0, 0)) { \
            __narwhalyzer_section_idx_##line = __narwhalyzer_register_section(name, file, line); \
        } \
        int __narwhalyzer_ctx_##line = __narwhalyzer_section_enter(__narwhalyzer_section_idx_##line); \
        narwhalyzer_scope_guard_t __narwhalyzer_guard_##line \
            __attribute__((cleanup(__narwhalyzer_scope_guard_cleanup))) = \
            { __narwhalyzer_ctx_##line, 1 };

#define NARWHALYZER_SECTION_END() \
    } while(0)

/*
 * Alternative macro for function-level instrumentation.
 * Places guard at function scope for automatic cleanup on return.
 */
#define NARWHALYZER_FUNCTION_INSTRUMENT(name) \
    static int __narwhalyzer_func_section_idx = -1; \
    if (__builtin_expect(__narwhalyzer_func_section_idx < 0, 0)) { \
        __narwhalyzer_func_section_idx = __narwhalyzer_register_section(name, __FILE__, __LINE__); \
    } \
    int __narwhalyzer_func_ctx = __narwhalyzer_section_enter(__narwhalyzer_func_section_idx); \
    narwhalyzer_scope_guard_t __narwhalyzer_func_guard \
        __attribute__((cleanup(__narwhalyzer_scope_guard_cleanup))) = \
        { __narwhalyzer_func_ctx, 1 }

/*
 * ============================================================================
 * Unstructured Region Macros
 * ============================================================================
 * 
 * These macros provide explicit control for instrumenting arbitrary code
 * regions that don't follow structured scoping rules. Use with:
 *   #pragma narwhalyzer start <name>
 *   #pragma narwhalyzer stop <name>
 * 
 * The pragma serves as documentation and can be used for static analysis,
 * while the macros provide the actual instrumentation.
 */

/*
 * Start an unstructured profiling region.
 * Must be paired with NARWHALYZER_STOP using the same name.
 * 
 * Usage:
 *   #pragma narwhalyzer start my_region
 *   NARWHALYZER_START(my_region);
 *   // ... arbitrary code, may span multiple scopes ...
 *   #pragma narwhalyzer stop my_region
 *   NARWHALYZER_STOP(my_region);
 * 
 * Note: The section name must be a valid C identifier.
 *       Context variables are created with the section name as suffix.
 */
#define NARWHALYZER_START(name) \
    static int __narwhalyzer_region_idx_##name = -1; \
    if (__builtin_expect(__narwhalyzer_region_idx_##name < 0, 0)) { \
        __narwhalyzer_region_idx_##name = __narwhalyzer_register_section(#name, __FILE__, __LINE__); \
    } \
    int __narwhalyzer_region_ctx_##name = __narwhalyzer_section_enter(__narwhalyzer_region_idx_##name)

/*
 * Stop an unstructured profiling region.
 * Must follow a corresponding NARWHALYZER_START with the same name.
 */
#define NARWHALYZER_STOP(name) \
    __narwhalyzer_section_exit(__narwhalyzer_region_ctx_##name)

/*
 * String-based variants for dynamic section names.
 * These use a lookup at each start/stop, which is slower but allows
 * section names determined at runtime or spanning compilation units.
 * 
 * Usage:
 *   NARWHALYZER_START_STR("dynamic_section");
 *   // ... code ...
 *   NARWHALYZER_STOP_CTX(ctx_var);
 * 
 * Note: Keep the context variable in scope between START and STOP.
 */
#define NARWHALYZER_START_STR(name_str, ctx_var) \
    do { \
        static int __narwhalyzer_dyn_idx = -1; \
        if (__builtin_expect(__narwhalyzer_dyn_idx < 0, 0)) { \
            __narwhalyzer_dyn_idx = __narwhalyzer_register_section(name_str, __FILE__, __LINE__); \
        } \
        ctx_var = __narwhalyzer_section_enter(__narwhalyzer_dyn_idx); \
    } while(0)

#define NARWHALYZER_STOP_CTX(ctx_var) \
    __narwhalyzer_section_exit(ctx_var)

#ifdef __cplusplus
}
#endif

#endif /* NARWHALYZER_H */
