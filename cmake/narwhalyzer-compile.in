#!/bin/bash
# Narwhalyzer Compiler Wrapper
# Compiles C/C++ source files with Narwhalyzer instrumentation
#
# This script can be invoked directly or via symlinks:
#   narwhalyzer-gcc   - uses gcc
#   narwhalyzer-g++   - uses g++
#   narwhalyzer-compile - auto-detects based on file extension
#
# Generated by CMake

set -e

# Paths configured by CMake
GCC_PATH="@GCC_EXECUTABLE@"
GXX_PATH="@GXX_EXECUTABLE@"
PLUGIN_PATH="@CMAKE_CURRENT_BINARY_DIR@/narwhalyzer.so"
INCLUDE_PATH="@CMAKE_CURRENT_SOURCE_DIR@/include"
RUNTIME_LIB="@CMAKE_CURRENT_BINARY_DIR@"

# Determine script name (handle symlinks)
SCRIPT_NAME="$(basename "$0")"

# Function to print usage
usage() {
    cat << EOF
Narwhalyzer Compiler Wrapper

Usage: $SCRIPT_NAME [compiler-options] <source-files...> [-o output]

This wrapper adds Narwhalyzer instrumentation to your C/C++ code.
All standard gcc/g++ options are supported.

Examples:
    $SCRIPT_NAME -O3 -o myprogram source.c
    $SCRIPT_NAME -lm -O2 examples/nested_example.c
    $SCRIPT_NAME -std=c++17 -o app main.cpp utils.cpp

Compiler Selection:
    narwhalyzer-gcc     Force use of gcc
    narwhalyzer-g++     Force use of g++
    narwhalyzer-compile Auto-detect from file extensions

Environment Variables:
    NARWHALYZER_VERBOSE=1    Enable verbose plugin output
    NARWHALYZER_CC           Override C compiler path
    NARWHALYZER_CXX          Override C++ compiler path

EOF
    exit 1
}

# Check for help or no arguments
if [ $# -eq 0 ] || [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
    usage
fi

# Determine compiler based on script name or file extensions
determine_compiler() {
    case "$SCRIPT_NAME" in
        *-gcc)
            echo "${NARWHALYZER_CC:-$GCC_PATH}"
            return
            ;;
        *-g++)
            echo "${NARWHALYZER_CXX:-$GXX_PATH}"
            return
            ;;
    esac

    # Auto-detect: scan arguments for C++ files
    for arg in "$@"; do
        case "$arg" in
            *.cpp|*.cxx|*.cc|*.C|*.CPP)
                echo "${NARWHALYZER_CXX:-$GXX_PATH}"
                return
                ;;
        esac
    done

    # Default to gcc for C files
    echo "${NARWHALYZER_CC:-$GCC_PATH}"
}

COMPILER="$(determine_compiler "$@")"

# Build plugin arguments
PLUGIN_ARGS="-fplugin=$PLUGIN_PATH"
if [ "${NARWHALYZER_VERBOSE:-0}" = "1" ]; then
    PLUGIN_ARGS="$PLUGIN_ARGS -fplugin-arg-narwhalyzer-verbose"
fi

# Check if plugin exists
if [ ! -f "$PLUGIN_PATH" ]; then
    echo "Error: Narwhalyzer plugin not found at: $PLUGIN_PATH" >&2
    echo "Please build the project first with: cmake --build <build-dir>" >&2
    exit 1
fi

# Separate compiler flags, source files, and linker flags
# This ensures libraries (-l*) come after source files
CFLAGS=()
SOURCES=()
LDFLAGS=()
OUTPUT_NEXT=0
OUTPUT=""

for arg in "$@"; do
    if [ "$OUTPUT_NEXT" = "1" ]; then
        OUTPUT="$arg"
        OUTPUT_NEXT=0
        continue
    fi
    
    case "$arg" in
        -o)
            OUTPUT_NEXT=1
            ;;
        -l*|-L*)
            LDFLAGS+=("$arg")
            ;;
        *.c|*.cc|*.cpp|*.cxx|*.C|*.CPP|*.c++|*.s|*.S|*.o|*.a)
            SOURCES+=("$arg")
            ;;
        *)
            CFLAGS+=("$arg")
            ;;
    esac
done

# Build output flag
OUTPUT_FLAG=()
if [ -n "$OUTPUT" ]; then
    OUTPUT_FLAG=(-o "$OUTPUT")
fi

# Execute the compiler with properly ordered arguments
exec "$COMPILER" \
    $PLUGIN_ARGS \
    -I"$INCLUDE_PATH" \
    -include narwhalyzer.h \
    "${CFLAGS[@]}" \
    "${SOURCES[@]}" \
    "${OUTPUT_FLAG[@]}" \
    -L"$RUNTIME_LIB" \
    -Wl,-rpath,"$RUNTIME_LIB" \
    -lnarwhalyzer \
    "${LDFLAGS[@]}" \
    -lpthread
